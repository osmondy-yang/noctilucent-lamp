# 设计模式
`**背:**` https://blog.csdn.net/qq_52211542/article/details/125648622
## 创建型模式
1.单例模式(Singleton):保证一个类只有一个实例，并提供一个访问它的全局访问点。关键字：单实例。
2.工厂方法模式(Factory Method):定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟。关键字：动态生产对象。
3.抽象工厂模式(Abstract Factory):提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类。关键字：生成系列对象。
4.建造者/构建器模式(Builder):将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示。关键字：复杂对象构造
5.原型模式(Prototype):用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象。关键字：克隆对象

## 结构型模式
1.适配器模式(Adapter):将一个类的接口转换成用户希望得到的另一种接口。使原本不相容的接口得以协同工作。关键字：转换接口
2.桥接模式(Bridge):将类的 抽象部分和它的实现部分 分离开，使他们可以独立地变化。关键字：继承树拆分
3.组合模式(Composite)：将对象组合成树形结构以表示"整体-部分"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。关键字：树形目录结构。
4.装饰模式(Decorator):动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活。关键字：附加职责。
5.外观模式(Facade):定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用。关键字：对外统一接口。
6.享元模式(Flyweight):提供支持大量细粒度对象共享的有效方法。关键字：文章共享文字对象。
7.代理模式(Proxy):为其他对象提供一种代理以控制这个对象的访问。关键字：快捷方式。

## 行为型模式
1.职责链模式(Chain of Responsibility):通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。关键字：传递职责
2.命令模式(Command):将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。关键字：日志记录，可撤销。
3.解释器模式(Interpreter):给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子。关键字：虚拟机的机制。
4.迭代器模式(Itertor):提供一种方法来顺序访问一个聚合对象中的各种元素，而不需要暴露该对象的内部表示。关键字：数据库数据集
5.中介者模式(Mediator):用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互。关键字：不直接引用。
6.备忘录模式(Memento):在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后该对象恢复到原先保存的状态。关键字：可恢复。
7.观察者模式(Observer):定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。关键字：联动。
8.状态模式(State):允许一个对象在其内部状态改变时改变他的行为。状态变成类。
9.策略模式(Strategy):定义一系列算法，把它们一个个封装起来，并且使他们之间可互相替换，从而让算法可以独立于使用它的用户而变化。关键字：多方案切换。
10.模板方法模式(Template Method):定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤。关键字：文档模板填空。
11.访问者模式(Visitor):表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作。关键字：数据与操作分离。

行为型模式对类或对象怎样交互和怎样分配职责进行描述。很多行为模式注重封装变化。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样，当该程序的其他部分依赖于这个方面时它们都可以与此对象协作。一些模式引入总是被用作参数的对象。有些模式定义一些可作为令牌进行传递的对象,这些对象将在稍后被调用。
在Visitor模式中，一个Visitor对象是一个多态的accept操作的参数，这个操作作用于该Visitor对象访问的对象。
令牌代表一个请求。在Command模式中，
在Memento模式中，它代表在一个对象在某个特定时刻的内部状态。在Command模式和Memento模式这两种情况下，令牌都可以有一个复杂的内部表示，但客户并不会意识到这-点。
在Observer模式中，通过引入Observer和Subject对象来分布通信.

# 7大设计原则
1.单一职责原则 (Single Responsibility Principle, SRP):目的单一的类，一个类应该只有一个引起它变化的原因。
2.开闭原则 (Open/Closed Principle, OCP):软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。
3.里氏替换原则 (Liskov Substitution Principle, LSP):子类必须能够替换其基类，并且程序的行为不会改变。
4.接口隔离原则 (Interface Segregation Principle, ISP):客户端不应该依赖于它不使用的接口。接口应该尽可能小，只包含一组相关的方法，避免“胖”接口。
5.依赖倒置原则 (Dependency Inversion Principle, DIP):高层模块不应该依赖低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。该原则鼓励使用依赖注入等技术来减少组件间的耦合度。
6.组合重用原则:尽量使用组合，而不是继承关系达到重用目的。
7.迪米特原则（最少知识法则）：一个对象应当对其他对象有可能少的了解
其他原则：
1.重用发布等价原则：重用的粒度就是发布的粒度
2.共同封闭原则：包中的所有类对于同一性质的变化应该是共同封闭的。一个变化若对一个包产生影响，而对其他的包不造成任何影响
3.共同重用原则：一个包里的所有类应该是共同重用的。如果重用了包里面的一个类，那么就要重用包中的所有类。
4.无环依赖原则：在包的依赖关系图中不允许存在环，即包之间的结构必须是一个直接的无环图形。
5.稳定依赖原则：朝着稳定的方向进行依赖。
6.稳定抽象原则：包的抽象程度应该和其稳定成都一致。